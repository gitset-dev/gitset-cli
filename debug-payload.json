{
  "repo_name": "gitset-dev/gitset-cli",
  "file_changes": [
    {
      "name": "package.json",
      "path": "package.json",
      "changeType": "modified",
      "contentType": "text",
      "changes": {
        "before": "{\n  \"name\": \"@gitset-dev/cli\",\n  \"version\": \"0.1.0\",\n  \"description\": \"AI-powered commit message generator - Create meaningful commit messages based on your staged changes\",\n  \"main\": \"src/index.js\",\n  \"type\": \"module\",\n  \"bin\": {\n    \"gitset\": \"./src/index.js\"\n  },\n  \"scripts\": {\n    \"prepare\": \"husky install && chmod +x src/index.js\",\n    \"postinstall\": \"chmod +x src/index.js\",\n    \"dev\": \"npm install && chmod +x src/index.js && npm link\",\n    \"start\": \"node src/index.js\",\n    \"test\": \"jest\",\n    \"lint\": \"eslint .\",\n    \"lint:fix\": \"eslint . --fix\",\n    \"format\": \"prettier --write .\",\n    \"preversion\": \"npm run lint && npm test\",\n    \"version\": \"npm run format && git add -A\",\n    \"postversion\": \"git push && git push --tags\"\n  },\n  \"engines\": {\n    \"node\": \">=18.0.0\"\n  },\n  \"keywords\": [\n    \"git\",\n    \"commit\",\n    \"message\",\n    \"ai\",\n    \"cli\",\n    \"gitset\",\n    \"commit-message\",\n    \"git-tools\"\n  ],\n  \"author\": {\n    \"name\": \"Gitset Dev Team\",\n    \"url\": \"https://github.com/gitset-dev\"\n  },\n  \"license\": \"MIT\",\n  \"dependencies\": {\n    \"commander\": \"^11.1.0\",\n    \"node-fetch\": \"^3.3.2\"\n  },\n  \"devDependencies\": {\n    \"jest\": \"^29.7.0\",\n    \"eslint\": \"^8.56.0\",\n    \"prettier\": \"^3.2.5\",\n    \"husky\": \"^9.0.11\",\n    \"lint-staged\": \"^15.2.2\",\n    \"@commitlint/cli\": \"^19.0.3\",\n    \"@commitlint/config-conventional\": \"^19.0.3\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/gitset-dev/gitset-cli.git\"\n  },\n  \"bugs\": {\n    \"url\": \"https://github.com/gitset-dev/gitset-cli/issues\"\n  },\n  \"homepage\": \"https://github.com/gitset-dev/gitset-cli#readme\",\n  \"publishConfig\": {\n    \"access\": \"public\",\n    \"registry\": \"https://registry.npmjs.org/\"\n  }\n}",
        "after": "{\n  \"name\": \"@gitset/cli\",\n  \"version\": \"0.1.1\",\n  \"description\": \"Generate semantic commit messages using AI-driven analysis of staged code changes.\",\n  \"main\": \"src/index.js\",\n  \"type\": \"module\",\n  \"bin\": {\n    \"gitset\": \"./src/index.js\"\n  },\n  \"scripts\": {\n    \"prepare\": \"husky install && chmod +x src/index.js\",\n    \"postinstall\": \"chmod +x src/index.js\",\n    \"dev\": \"npm install && chmod +x src/index.js && npm link\",\n    \"start\": \"node src/index.js\",\n    \"test\": \"jest\",\n    \"lint\": \"eslint .\",\n    \"lint:fix\": \"eslint . --fix\",\n    \"format\": \"prettier --write .\",\n    \"preversion\": \"npm run lint && npm test\",\n    \"version\": \"npm run format && git add -A\",\n    \"postversion\": \"git push && git push --tags\"\n  },\n  \"engines\": {\n    \"node\": \">=18.0.0\"\n  },\n  \"keywords\": [\n    \"git\",\n    \"commit\",\n    \"message\",\n    \"ai\",\n    \"cli\",\n    \"gitset\",\n    \"commit-message\",\n    \"git-tools\"\n  ],\n  \"author\": {\n    \"name\": \"Gitset Dev Team\",\n    \"url\": \"https://github.com/gitset-dev\"\n  },\n  \"license\": \"MIT\",\n  \"dependencies\": {\n    \"commander\": \"^11.1.0\",\n    \"node-fetch\": \"^3.3.2\"\n  },\n  \"devDependencies\": {\n    \"jest\": \"^29.7.0\",\n    \"eslint\": \"^8.56.0\",\n    \"prettier\": \"^3.2.5\",\n    \"husky\": \"^9.0.11\",\n    \"lint-staged\": \"^15.2.2\",\n    \"@commitlint/cli\": \"^19.0.3\",\n    \"@commitlint/config-conventional\": \"^19.0.3\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/gitset-dev/gitset-cli.git\"\n  },\n  \"bugs\": {\n    \"url\": \"https://github.com/gitset-dev/gitset-cli/issues\"\n  },\n  \"homepage\": \"https://github.com/gitset-dev/gitset-cli#readme\",\n  \"publishConfig\": {\n    \"access\": \"public\",\n    \"registry\": \"https://registry.npmjs.org/\"\n  }\n}"
      }
    },
    {
      "name": "index.js",
      "path": "src/index.js",
      "changeType": "modified",
      "contentType": "text",
      "changes": {
        "before": "#!/usr/bin/env node \nimport { exec } from 'child_process';\nimport { promisify } from 'util';\nimport fetch from 'node-fetch';\nimport { program } from 'commander';\nimport path from 'path';\nimport fs from 'fs/promises';\n\nconst execAsync = promisify(exec);\n\nfunction log(step, message, isError = false) {\n    const timestamp = new Date().toLocaleTimeString();\n    const prefix = isError ? '❌' : '✨';\n    console.log(`${prefix} [${timestamp}] ${step}: ${message}`);\n}\n\nfunction getFormattedTimestamp() {\n    return new Date().toISOString().replace(/[:.]/g, '-');\n}\n\nasync function getGitDiff(file) {\n    try {\n        log('Diff', `Getting differences for ${file}...`);\n        const { stdout: lastCommit } = await execAsync('git rev-parse HEAD');\n        \n        let previousContent = '';\n        try {\n            const { stdout } = await execAsync(`git show ${lastCommit.trim()}:${file}`);\n            previousContent = stdout;\n            log('Diff', `✓ Retrieved previous content (${stdout.length} bytes)`);\n        } catch (e) {\n            log('Diff', `New file detected: ${file}`);\n        }\n\n        const { stdout: currentContent } = await execAsync(`git show :${file}`);\n        log('Diff', `✓ Retrieved current content (${currentContent.length} bytes)`);\n\n        return {\n            previous: previousContent,\n            current: currentContent\n        };\n    } catch (error) {\n        log('Diff', `Error processing ${file}: ${error.message}`, true);\n        return { previous: '', current: '' };\n    }\n}\n\nasync function getRepoInfo() {\n    try {\n        log('Repo', 'Retrieving repository information...');\n        const { stdout: remoteUrl } = await execAsync('git config --get remote.origin.url');\n        const repoPath = remoteUrl.trim()\n            .replace('git@github.com:', '')\n            .replace('https://github.com/', '')\n            .replace('.git', '');\n        log('Repo', `✓ Repository identified: ${repoPath}`);\n        return repoPath;\n    } catch (error) {\n        log('Repo', `Error: ${error.message}`, true);\n        return '';\n    }\n}\n\nasync function getStagedFiles() {\n    try {\n        log('Git', 'Looking for staged files...');\n        const { stdout } = await execAsync('git diff --cached --name-status');\n        const files = stdout.split('\\n')\n            .filter(line => line)\n            .map(line => {\n                const [status, ...fileParts] = line.split('\\t');\n                return { status, file: fileParts.join('\\t') };\n            });\n        \n        log('Git', `✓ Found ${files.length} staged files`);\n        return files;\n    } catch (error) {\n        log('Git', `Error: ${error.message}`, true);\n        return [];\n    }\n}\n\nfunction formatFileContent(fileName, status, previousContent, currentContent) {\n    return `File: ${fileName}\nStatus: ${status}\n\n----- PREVIOUS VERSION -----\n${previousContent || '[New File - No Previous Content]'}\n\n----- CURRENT VERSION -----\n${currentContent || '[File Deleted - No Current Content]'}\n\n========================================\n`;\n}\n\nasync function saveChangesToFile(fileChanges) {\n    try {\n        const logsDir = path.join(process.cwd(), 'logs');\n        await fs.mkdir(logsDir, { recursive: true });\n\n        const timestamp = getFormattedTimestamp();\n        const logFile = path.join(logsDir, `changes-${timestamp}.txt`);\n\n        let fullContent = `Changes Log - ${new Date().toLocaleString()}\\n\\n`;\n\n        for (const change of fileChanges) {\n            fullContent += formatFileContent(\n                change.path,\n                change.changeType,\n                change.changes.before,\n                change.changes.after\n            );\n        }\n\n        await fs.writeFile(logFile, fullContent, 'utf8');\n        return logFile;\n    } catch (error) {\n        console.error('Error saving changes:', error);\n        throw error;\n    }\n}\n\nasync function generateCommitMessage() {\n    try {\n        log('Start', 'Starting commit message generation process...');\n\n        const files = await getStagedFiles();\n        if (files.length === 0) {\n            log('Git', 'No files staged. Use git add first.', true);\n            return;\n        }\n\n        log('Files', 'Analyzing:');\n        files.forEach(({ status, file }) => {\n            const statusText = {\n                'A': '➕ Added',\n                'M': '📝 Modified',\n                'D': '❌ Deleted'\n            }[status] || status;\n            console.log(`   ${statusText}: ${file}`);\n        });\n\n        const fileChanges = await Promise.all(\n            files.map(async ({ status, file }) => {\n                const { previous, current } = await getGitDiff(file);\n                const extension = path.extname(file).toLowerCase();\n\n                return {\n                    name: path.basename(file),\n                    path: file,\n                    changeType: status === 'A' ? 'added' : status === 'M' ? 'modified' : 'deleted',\n                    contentType: ['.jpg', '.png', '.gif', '.pdf'].includes(extension) ? 'binary' : 'text',\n                    changes: {\n                        before: previous,\n                        after: current\n                    }\n                };\n            })\n        );\n\n        const logFilePath = await saveChangesToFile(fileChanges);\n        log('Log', `Changes saved to: ${logFilePath}`);\n\n        const repoName = await getRepoInfo();\n        log('API', 'Sending information to the server...');\n        \n        const response = await fetch('https://gitset-commit-messages.vercel.app/generate-commit-message', {\n            method: 'POST',\n            headers: { 'Content-Type': 'application/json' },\n            body: JSON.stringify({\n                repo_name: repoName,\n                file_changes: fileChanges\n            })\n        });\n\n        if (!response.ok) {\n            const errorData = await response.text();\n            throw new Error(`Server error (${response.status}): ${errorData}`);\n        }\n\n        const { commit_message } = await response.json();\n        log('Success', '✨ Commit message generated\\n');\n        console.log('📝 Suggested message:');\n        console.log('------------------');\n        console.log(commit_message);\n        console.log('------------------');\n        console.log('\\n💡 To use this message:');\n        console.log(`git commit -m \"${commit_message}\"`);\n\n    } catch (error) {\n        log('Error', error.message, true);\n        process.exit(1);\n    }\n}\n\nprogram\n    .name('gitset')\n    .description('AI-powered commit message generator - Creates meaningful commit messages based on your staged changes')\n    .version('0.1.0')\n    .action(generateCommitMessage);\n\nprogram.parse();",
        "after": "#!/usr/bin/env node \nimport { exec } from 'child_process';\nimport { promisify } from 'util';\nimport fetch from 'node-fetch';\nimport { program } from 'commander';\nimport path from 'path';\nimport fs from 'fs/promises';\n\nconst execAsync = promisify(exec);\n\n// Terminal colors using ANSI escape codes\nconst colors = {\n    reset: '\\x1b[0m',\n    bright: '\\x1b[1m',\n    green: '\\x1b[32m',\n    yellow: '\\x1b[33m',\n    blue: '\\x1b[34m',\n    magenta: '\\x1b[35m',\n    cyan: '\\x1b[36m',\n    red: '\\x1b[31m'\n};\n\nfunction log(step, message, isError = false) {\n    const timestamp = new Date().toLocaleTimeString();\n    const prefix = isError ? colors.red + '❌' : colors.green + '✨';\n    const stepColor = isError ? colors.red : colors.cyan;\n    console.log(`${prefix} ${colors.reset}[${timestamp}] ${stepColor}${step}${colors.reset}: ${message}`);\n}\n\nasync function getGitDiff(file) {\n    try {\n        log('Diff', `Getting differences for ${file}...`);\n        const { stdout: lastCommit } = await execAsync('git rev-parse HEAD');\n        \n        let previousContent = '';\n        try {\n            const { stdout } = await execAsync(`git show ${lastCommit.trim()}:${file}`);\n            const lineCount = stdout.split('\\n').length;\n            if (lineCount > MAX_LINES) {\n                log('Diff', `Skipping ${file}: exceeds ${MAX_LINES} lines (has ${lineCount} lines)`, true);\n                return null;\n            }\n            previousContent = stdout;\n            log('Diff', `✓ Retrieved previous content (${stdout.length} bytes, ${lineCount} lines)`);\n        } catch (e) {\n            log('Diff', `New file detected: ${file}`);\n        }\n\n        const { stdout: currentContent } = await execAsync(`git show :${file}`);\n        const currentLineCount = currentContent.split('\\n').length;\n        if (currentLineCount > MAX_LINES) {\n            log('Diff', `Skipping ${file}: exceeds ${MAX_LINES} lines (has ${currentLineCount} lines)`, true);\n            return null;\n        }\n        log('Diff', `✓ Retrieved current content (${currentContent.length} bytes, ${currentLineCount} lines)`);\n\n        return {\n            previous: previousContent,\n            current: currentContent\n        };\n    } catch (error) {\n        log('Diff', `Error processing ${file}: ${error.message}`, true);\n        return null;\n    }\n}\n\nasync function getRepoInfo() {\n    try {\n        log('Repo', 'Retrieving repository information...');\n        const { stdout: remoteUrl } = await execAsync('git config --get remote.origin.url');\n        const repoPath = remoteUrl.trim()\n            .replace('git@github.com:', '')\n            .replace('https://github.com/', '')\n            .replace('.git', '');\n        log('Repo', `✓ Repository identified: ${repoPath}`);\n        return repoPath;\n    } catch (error) {\n        log('Repo', `Error: ${error.message}`, true);\n        return '';\n    }\n}\n\n// Files that should typically be ignored\nconst IGNORED_FILES = [\n    'package-lock.json',\n    'yarn.lock',\n    'pnpm-lock.yaml',\n    '.env',\n    'venv',\n    'node_modules',\n    '.DS_Store',\n    'dist',\n    'build',\n    '__pycache__',\n    '.pytest_cache',\n    'coverage'\n];\n\nconst MAX_LINES = 3000;\n\nfunction shouldIgnoreFile(filePath) {\n    return IGNORED_FILES.some(ignored => \n        filePath === ignored || \n        filePath.startsWith(ignored + '/') || \n        filePath.includes('/node_modules/') ||\n        filePath.includes('/__pycache__/') ||\n        filePath.includes('/venv/')\n    );\n}\n\nasync function getStagedFiles() {\n    try {\n        log('Git', 'Looking for staged files...');\n        const { stdout } = await execAsync('git diff --cached --name-status');\n        const files = stdout.split('\\n')\n            .filter(line => line)\n            .map(line => {\n                const [status, ...fileParts] = line.split('\\t');\n                const file = fileParts.join('\\t');\n                return { status, file };\n            })\n            .filter(({ file }) => !shouldIgnoreFile(file));\n        \n        log('Git', `✓ Found ${files.length} staged files`);\n        return files;\n    } catch (error) {\n        log('Git', `Error: ${error.message}`, true);\n        return [];\n    }\n}\n\nasync function generateCommitMessage() {\n    try {\n        log('Start', 'Starting commit message generation process...');\n\n        const files = await getStagedFiles();\n        if (files.length === 0) {\n            log('Git', 'No files staged. Use git add first.', true);\n            return;\n        }\n\n        log('Files', 'Analyzing:');\n        files.forEach(({ status, file }) => {\n            const statusText = {\n                'A': `${colors.green}➕ Added`,\n                'M': `${colors.yellow}📝 Modified`,\n                'D': `${colors.red}❌ Deleted`\n            }[status] || status;\n            console.log(`   ${statusText}${colors.reset}: ${file}`);\n        });\n\n        const fileChanges = (await Promise.all(\n            files.map(async ({ status, file }) => {\n                const diffResult = await getGitDiff(file);\n                if (!diffResult) return null;\n                \n                const { previous, current } = diffResult;\n                const extension = path.extname(file).toLowerCase();\n\n                return {\n                    name: path.basename(file),\n                    path: file,\n                    changeType: status === 'A' ? 'added' : status === 'M' ? 'modified' : 'deleted',\n                    contentType: ['.jpg', '.png', '.gif', '.pdf'].includes(extension) ? 'binary' : 'text',\n                    changes: {\n                        before: previous,\n                        after: current\n                    }\n                };\n            })\n        )).filter(change => change !== null);\n\n        const repoName = await getRepoInfo();\n        log('API', 'Sending information to the server...');\n        \n        // Save the payload for debugging\n        const payload = {\n            repo_name: repoName,\n            file_changes: fileChanges\n        };\n        \n        // Save payload to debug file\n        await fs.writeFile('debug-payload.json', JSON.stringify(payload, null, 2));\n        log('Debug', `Payload saved to debug-payload.json (${JSON.stringify(payload).length} bytes)`);\n\n        const response = await fetch('https://gitset-commit-messages.vercel.app/generate-commit-message', {\n            method: 'POST',\n            headers: { 'Content-Type': 'application/json' },\n            body: JSON.stringify({\n                repo_name: repoName,\n                file_changes: fileChanges\n            })\n        });\n\n        if (!response.ok) {\n            const errorData = await response.text();\n            let errorMessage;\n            \n            try {\n                const parsedError = JSON.parse(errorData);\n                if (response.status === 500 && parsedError.message?.includes('429')) {\n                    errorMessage = `${colors.yellow}The API rate limit has been reached. Please try again in a few minutes.${colors.reset}`;\n                } else {\n                    errorMessage = `Server error (${response.status}): ${parsedError.message || errorData}`;\n                }\n            } catch {\n                errorMessage = `Server error (${response.status}): ${errorData}`;\n            }\n            \n            throw new Error(errorMessage);\n        }\n\n        const { commit_message } = await response.json();\n        log('Success', '✨ Commit message generated\\n');\n        console.log(`${colors.bright}📝 Suggested message:${colors.reset}`);\n        console.log(`${colors.yellow}------------------${colors.reset}`);\n        console.log(`${colors.bright}${colors.magenta}${commit_message}${colors.reset}`);\n        console.log(`${colors.yellow}------------------${colors.reset}`);\n        console.log(`\\n${colors.bright}💡 To use this message:${colors.reset}`);\n        console.log(`${colors.cyan}git commit -m \"${colors.magenta}${commit_message}${colors.cyan}\"${colors.reset}`);\n\n    } catch (error) {\n        log('Error', error.message, true);\n        process.exit(1);\n    }\n}\n\nprogram\n    .name('gitset')\n    .description('Generate semantic commit messages using AI-driven analysis of staged code changes.')\n    .version('0.1.1')\n    .action(generateCommitMessage);\n\nprogram.parse();"
      }
    }
  ]
}